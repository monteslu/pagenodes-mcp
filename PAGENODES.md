# PageNodes Integration Guide

PageNodes is a visual flow programming editor. Users drag nodes onto a canvas, connect them with wires, and deploy to run. It can run standalone in a browser (Web Worker runtime) or as a Node.js server.

> **How it works:** Use `add_nodes` to add multiple nodes at once. Give each node a `tempId` (like "a", "b", "c") and use those tempIds in `wires`. The system automatically converts tempIds to real generated IDs.

## Architecture

```
PageNodes Instance
├── Editor UI (React)
│   ├── Canvas - drag/drop nodes, draw wires
│   ├── Palette - available node types
│   ├── Sidebar - debug output, node help
│   └── Deploy button
│
└── Runtime (Web Worker or Node.js)
    ├── Flow execution engine
    ├── Node instances
    └── Message passing
```

## How PageNodes Works

### Message Flow
Nodes process messages and pass them downstream. A message is a JavaScript object:
```javascript
{
  payload: "the main data",
  topic: "optional category",
  // ...any other properties
}
```

Nodes receive messages on input ports, do something, and send messages out output ports.

### Node Types
The node catalog contains all available nodes. Each entry describes:
- `type` - unique identifier (e.g., "inject", "function", "mqtt in")
- `category` - grouping (common, input, output, ai, logic, transforms, networking, hardware, storage)
- `inputs` / `outputs` - number of ports
- `defaults` - configurable properties with types and default values
- `description` - what the node does

Use `get_node_details` to get full property definitions for a specific node type. The response may include:
- `defaults` - All configurable properties with types, defaults, and descriptions
- `help` - HTML documentation explaining usage
- `relatedDocs` - Array of external documentation links: `[{ label: "MDN Docs", url: "https://..." }]`

### Node IDs

Every node has a unique ID. Understanding the ID system is important for creating flows correctly.

**Real IDs:**
- Generated by PageNodes when nodes are created
- Format: 22-character URL-safe base64-encoded UUID (e.g., `"XWfw36QmR--u3xR9DHCeyQ"`)
- Stored in `node.id`
- Used for: `update_node`, `delete_node`, `inject_node`, `trigger_node`, config node references

**Temp IDs (tempId):**
- You define these when calling `add_nodes`
- Can be any string you choose (e.g., `"a"`, `"b"`, `"inject1"`, `"myFunction"`)
- Used only for wiring nodes together in a single `add_nodes` call
- Automatically converted to real IDs by the server

**How `add_nodes` handles IDs:**

1. You provide nodes with `tempId` values and `wires` referencing those tempIds
2. Server generates real IDs for each node
3. Server builds a `tempId → realId` mapping
4. Server replaces tempIds in `wires` with real IDs
5. Server returns both the tempId and the generated real ID for each node

**Example:**
```javascript
// You send:
add_nodes({
  flowId: "flow1",
  nodes: [
    { tempId: "a", type: "inject", x: 100, y: 100, wires: [["b"]] },
    { tempId: "b", type: "debug", x: 300, y: 100 }
  ]
});

// Response:
{
  "success": true,
  "nodes": [
    { "tempId": "a", "id": "XWfw36QmR--u3xR9DHCeyQ", "node": {...} },
    { "tempId": "b", "id": "DxhXDDIhSjSs7VOdix1Yug", "node": {...} }
  ]
}
```

The returned `id` is the real ID you need for subsequent operations like `update_node` or `delete_node`.

**When you need real IDs:**
- Referencing config nodes (they must exist first)
- Updating or deleting nodes after creation
- Triggering inject nodes
- Any operation on existing nodes

**When you use tempIds:**
- Wiring nodes together within a single `add_nodes` call
- TempIds only work within that one call - they're not stored

### Config Nodes

Config nodes store shared configuration that multiple flow nodes can reference. They don't appear on the canvas and have no inputs or outputs - they just hold settings.

**Why config nodes exist:**
- **Shared connections**: Multiple MQTT nodes can share one broker connection
- **Reusable settings**: Multiple LLM nodes can share one model configuration
- **Centralized management**: Change the broker URL once, all dependent nodes update

Config nodes have `category: "config"` in the node catalog. Use `get_node_details` on a node to see if it references a config node (look for properties whose `type` is a config node type).

**How regular nodes reference config nodes:**

When a node needs a config node, its `defaults` includes a property whose `type` is the config node type. For example, `mqtt in` has:
```javascript
defaults: {
  broker: { type: 'mqtt-broker', required: true },  // references config node
  topic: { type: 'string' },
  // ...
}
```

The `broker` property stores the **ID** of the config node instance.

**Checking existing config nodes:**

Call `get_flows()` - the response includes a `configNodes` array:
```javascript
{
  flows: [...],
  nodes: [...],
  configNodes: [
    {
      "id": "abc123",
      "type": "mqtt-broker",
      "name": "My Broker",
      "broker": "wss://test.mosquitto.org:8081",
      "username": "",
      "password": "",
      // ...
    }
  ]
}
```

**Reusing existing config nodes:**

Before creating a new config node, check if one already exists:
```javascript
const flows = get_flows();
const existingBroker = flows.configNodes.find(c =>
  c.type === 'mqtt-broker' &&
  c.broker === 'wss://test.mosquitto.org:8081'
);

if (existingBroker) {
  // Reuse it
  brokerId = existingBroker.id;
} else {
  // Create new one
  const result = add_nodes({ flowId, nodes: [{ tempId: "broker", type: "mqtt-broker", ... }] });
  brokerId = result.nodes[0].id;
}
```

**Creating config nodes:**

Config nodes are created via `add_nodes` like regular nodes, but:
- They have no wires (no inputs/outputs)
- Position (x, y) doesn't matter (they're not on canvas)
- Use convention `x: 0, y: 0` for clarity

```javascript
add_nodes({
  flowId: flowId,
  nodes: [{
    tempId: "broker",
    type: "mqtt-broker",
    x: 0, y: 0,
    name: "Production Broker",
    broker: "wss://mqtt.example.com:8084",
    username: "user",
    password: "pass"
  }]
});
```

**Two-step pattern for flows with config nodes:**

1. Create the config node first (or find existing one) to get its real ID
2. Create flow nodes that reference the config node ID

```javascript
// Step 1: Create config node
const configResult = add_nodes({
  flowId,
  nodes: [{
    tempId: "config",
    type: "llm-config",
    x: 0, y: 0,
    task: "text-generation",
    model: "onnx-community/Qwen2.5-0.5B-Instruct",
    device: "webgpu",
    dtype: "q4"
  }]
});
const configId = configResult.nodes[0].id;

// Step 2: Create flow nodes referencing the config
add_nodes({
  flowId,
  nodes: [
    { tempId: "inject", type: "inject", x: 100, y: 100, wires: [["llm"]], payloadType: "str", payload: "Hello" },
    { tempId: "llm", type: "llm", x: 270, y: 100, wires: [["debug"]], config: configId },
    { tempId: "debug", type: "debug", x: 440, y: 100 }
  ]
});
```

> **Important**: You cannot use tempIds to reference config nodes in the same `add_nodes` call. The config node must exist first so you have its real ID.

### Wires

Wires connect nodes together. Without wires, messages cannot flow between nodes.

Each node has a `wires` property - an array of arrays. Each inner array lists the nodes that output port connects to:

```javascript
wires: [
  ["b", "c"],  // output 0 connects to nodes "b" and "c"
  ["d"]        // output 1 connects to node "d"
]
```

Most nodes have 1 output, so typically: `wires: [["targetTempId"]]`

**Examples:**
```javascript
wires: [["b"]]           // output 0 → node b
wires: [["b", "c"]]      // output 0 → nodes b AND c (fan-out)
wires: [["b"], ["c"]]    // output 0 → b, output 1 → c (e.g., switch)
wires: [[]]              // no connections (terminal node like debug)
```

### Deploy
Changes don't take effect until deployed. Deploy pushes the current flow configuration to the runtime, which instantiates nodes and starts message flow.

## Creating Flows

### Using add_nodes

The `add_nodes` function adds multiple nodes in a single call. Each node gets a `tempId` that you use for wiring. The server converts tempIds to real IDs automatically.

**Node properties go at top level.** All properties (id, type, x, y, wires, and node-specific config) are flat on the node object.

```javascript
add_nodes({
  flowId: "flow1",
  nodes: [
    { tempId: "a", type: "inject", x: 100, y: 100, wires: [["b"]], payloadType: "str", payload: "hello" },
    { tempId: "b", type: "function", x: 250, y: 100, wires: [["c"]], func: "return msg;" },
    { tempId: "c", type: "debug", x: 400, y: 100, active: true, tosidebar: true }
  ]
})
```

This creates: `[inject] → [function] → [debug]`

### Workflow

1. **Start here**: Call `get_started` first to get node catalog and current state
2. **Choose a flow**: Use existing flowId or `create_flow` for a new tab
3. **Plan the pipeline**: Decide what nodes you need and how they connect
4. **Get node details**: Call `get_node_details` for each node type you plan to use. This returns:
   - All configurable properties with types and defaults
   - Required vs optional fields
   - Help documentation explaining usage
5. **Call add_nodes**: Add all nodes with tempIds, wires, and proper config properties
6. **Deploy**: Call `deploy` to activate
7. **Check results**: Use `get_debug_output` to see debug output

> **Tip**: Don't guess at node properties. Always call `get_node_details("node-type")` to see exactly what properties are available and what they do.

### Example: Simple Transform Pipeline

Goal: `[inject "hello"] → [function: uppercase] → [debug]`

```javascript
// 1. Get a flow ID
const flows = get_flows();
const flowId = flows.flows[0].id;

// 2. Add all nodes at once with tempIds
add_nodes({
  flowId: flowId,
  nodes: [
    {
      tempId: "inject1",
      type: "inject",
      x: 100, y: 100,
      wires: [["func1"]],
      payloadType: "str",
      payload: "hello world"
    },
    {
      tempId: "func1",
      type: "function",
      x: 270, y: 100,
      wires: [["debug1"]],
      func: "msg.payload = msg.payload.toUpperCase();\nreturn msg;"
    },
    {
      tempId: "debug1",
      type: "debug",
      x: 440, y: 100
      // no wires - terminal node
    }
  ]
});

// 3. Deploy
deploy();
```

### Example: Using Config Nodes

Config nodes (like MQTT broker) need to be created first since they have real IDs that regular nodes reference.

Goal: MQTT subscriber

```javascript
// 1. Get flow
const flows = get_flows();
const flowId = flows.flows[0].id;

// 2. Create config node first (returns real ID)
const broker = add_nodes({
  flowId: flowId,
  nodes: [{
    tempId: "broker",
    type: "mqtt-broker",
    x: 0, y: 0,  // config nodes don't show on canvas
    name: "Test Broker",
    broker: "wss://test.mosquitto.org:8081"
  }]
});
const brokerId = broker.nodes[0].id;  // real generated ID

// 3. Add flow nodes referencing the broker
add_nodes({
  flowId: flowId,
  nodes: [
    {
      tempId: "mqtt",
      type: "mqtt in",
      x: 150, y: 100,
      wires: [["debug"]],
      broker: brokerId,  // reference the real config node ID
      topic: "test/topic",
      qos: 0
    },
    {
      tempId: "debug",
      type: "debug",
      x: 350, y: 100
    }
  ]
});

// 4. Deploy
deploy();
```

## Updating Nodes

The `update_node` function modifies existing nodes. Understanding the node structure is critical to avoid breaking nodes.

### Node Structure

Each node is a flat object with all properties at the top level:

**Core properties** (managed by PageNodes):
- `id` - Unique identifier (never change this)
- `type` - Node type (never change this)
- `name` - Display name
- `x`, `y` - Canvas position
- `z` - Flow ID
- `wires` - Message connections `[[targetId1, targetId2], [targetId3]]`
- `streamWires` - Audio connections (same format)

**Node-specific properties** (varies by node type):
- e.g., `payload`, `func`, `broker`, `topic`

### How update_node Works

`update_node` performs a **shallow merge** of your `updates` object into the node:
- Properties you specify are updated
- Properties you don't specify are preserved

### Safe Updates (DO THIS)

Update **top-level config properties** directly:

```javascript
// Update a function node's code
update_node({
  nodeId: "abc123",
  updates: { func: "msg.payload = msg.payload.toUpperCase();\nreturn msg;" }
});

// Update position
update_node({
  nodeId: "abc123",
  updates: { x: 300, y: 200 }
});

// Update a debug node's settings
update_node({
  nodeId: "xyz789",
  updates: { complete: "true", active: true }
});

// Update multiple properties at once
update_node({
  nodeId: "abc123",
  updates: { payload: "new value", topic: "new/topic" }
});
```

### Updating Wires

Since nodes are flat objects, you can update wires directly:

```javascript
// Update wires on an existing node
update_node({
  nodeId: "abc123",
  updates: { wires: [["newTarget", "anotherTarget"]] }
});
```

Alternatively, delete and recreate the node:
```javascript
// Get current node config from get_flows()
// Delete old node
delete_node({ nodeId: "abc123" });
// Add new node with correct wires
add_nodes({ flowId, nodes: [{ ...nodeConfig, wires: [["newTarget"]] }] });
```

### Summary

| What to update | How to do it |
|----------------|--------------|
| Node config (func, payload, topic, etc.) | Pass property directly in `updates` |
| Position (x, y) | Pass `x` and/or `y` directly in `updates` |
| Display name | Pass `name` directly in `updates` |
| Wires | Pass `wires` directly in `updates`, or delete and recreate |

## Node Positioning

Nodes have `x`, `y` coordinates on the canvas.

**Do not overlap existing nodes.** Always check current node positions via `get_flows` before adding new nodes.

**Avoid long straight lines.** Instead of placing 6 nodes in a horizontal row, use a wave pattern:

```
Bad (hard to read, runs off screen):
[1]───[2]───[3]───[4]───[5]───[6]

Good (wave pattern):
[1]───[2]───[3]
              │
[6]───[5]───[4]
```

Guidelines:
- Horizontal spacing: ~150-170px between nodes
- Vertical spacing: ~80-100px between rows
- After 3-4 nodes horizontally, drop down and continue (or loop back)
- Left-to-right flow is conventional (inputs on left, outputs on right)
- Check existing nodes and place new flows in empty canvas areas

## User Gestures

Nodes that access hardware or media APIs (camera, microphone, bluetooth, sensors, audio, etc.) require a user gesture before activating. Check the node's help text via `get_node_details` for specifics. Tell users they may need to click in the browser to activate these nodes.

## Audio Nodes (Web Audio API)

Audio nodes in the `audio` category use the Web Audio API. They have **two types of ports**:

- **Yellow ports**: Message inputs/outputs for control (play, stop, parameter changes)
- **Green ports**: Audio stream connections carrying actual audio signal

Use `get_node_details` on audio node types to see their stream port configuration (`streamInputs`, `streamOutputs`) and available parameters. Audio stream wires use `streamWires` in the same format as regular `wires`.

## Common Patterns

### Periodic Polling
```
[inject repeat:"30"] → [http request] → [json] → [debug]
```
Inject with repeat interval triggers HTTP request every 30 seconds.

### Conditional Routing
```
[switch] → output0 (if msg.payload > 100)
        → output1 (if msg.payload <= 100)
        → output2 (otherwise)
```
Switch node routes messages based on conditions.

### Fan-out
```
[inject] → [nodeA]
        → [nodeB]
        → [nodeC]
```
One output wired to multiple targets: `wires: [["nodeA", "nodeB", "nodeC"]]`

### Aggregation
```
[source1] → [join] → [debug]
[source2] →
```
Join node combines messages from multiple sources.

### Cross-flow Communication
```
Flow 1: [...] → [link out name:"signal"]
Flow 2: [link in name:"signal"] → [...]
```
Link nodes pass messages between flows.

### Error Handling
```
[any node that might error]
        ↓ (error)
[catch] → [debug]
```
The `catch` node receives errors from other nodes in the flow. When a node calls `this.error()`, the error is routed to catch nodes. The error message includes:
- `msg.error.message` - Error text
- `msg.error.source.id` - ID of the node that errored
- `msg.error.source.type` - Type of the node
- `msg.error.source.name` - Name of the node
- `msg.error.stack` - Stack trace (if available)
- `msg._msgid` - Original message ID for tracing

Catch node scope options:
- **All nodes** - Catches errors from any node
- **Uncaught errors only** - Only catches errors not handled by another catch node

## Debugging

- **debug node**: Sends `msg.payload` (or full msg) to sidebar. Essential for seeing what's happening.
- **get_debug_output**: Retrieve recent debug messages programmatically.
- **get_errors**: Retrieve runtime errors (when nodes throw exceptions).
- **Node status**: Nodes show status indicators (colored dots + text) for their state.

## Testing Flows Programmatically

After deploying a flow, you can test it using `inject_node` and trace messages through the flow using `_msgid`.

### Workflow

1. **Find inject nodes**: Call `get_inject_nodes` to list all inject nodes with their IDs and configurations
2. **Trigger an inject**: Call `inject_node` with the node ID - returns `{ success: true, _msgid: "..." }`
3. **Check output**: Call `get_debug_output` and find messages with the matching `_msgid`
4. **Check errors**: Call `get_errors` to see if any nodes threw exceptions

### Message Tracing with `_msgid`

Every message in PageNodes has a `_msgid` for tracing. When you call `inject_node`, it returns the `_msgid` of the injected message. This same ID appears in debug output, allowing you to trace your specific message through the flow.

```javascript
// 1. Trigger inject (uses node's configured payload)
const result = inject_node({ nodeId: "abc123" });
// Returns: { success: true, _msgid: "xyz789" }

// 2. Check debug output
const debug = get_debug_output({ limit: 5 });
// Find entries where _msgid === "xyz789" to see your message

// 3. Check for errors
const errors = get_errors({ limit: 5 });
// Errors also include _msgid for correlation
```

### Overriding Payload

You can inject a custom payload instead of using the node's configured value:

```javascript
// Inject with custom payload
inject_node({ nodeId: "abc123", payload: "test data" });
inject_node({ nodeId: "abc123", payload: { foo: "bar" } });
inject_node({ nodeId: "abc123", payload: 42 });
```

If no payload is provided, the inject node uses its configured `payloadType`:
- `date` - Current timestamp (Date.now())
- `str` - String value
- `num` - Number value
- `json` - Parsed JSON object
- `bool` - Boolean value

### Triggering Any Node

Use `trigger_node` to send a message to ANY node's input, not just inject nodes:

```javascript
// Send a message directly to a function node
trigger_node({
  nodeId: "functionNode123",
  msg: { payload: "test data", topic: "test" }
});

// Trigger a node mid-flow for testing
trigger_node({
  nodeId: "switchNode456",
  msg: { payload: 150, _msgid: "trace123" }
});
```

This is useful for:
- Testing nodes in isolation
- Flows that start with event-driven nodes (mqtt-in, websocket-in)
- Sending test data to specific points in a flow

### Clean Slate Testing

Before running tests, clear the buffers to isolate results:

```javascript
// Clear previous output
clear_debug();
clear_errors();

// Run test
inject_node({ nodeId: "abc123" });

// Check only the new output
const results = get_debug_output({ limit: 10 });
```

### Monitoring Node Status

Check if nodes are connected/ready:

```javascript
const statuses = get_node_statuses();
// Returns: { "nodeId1": { fill: "green", shape: "dot", text: "connected" }, ... }
```

Status objects have:
- `fill` - Color (green, yellow, red, grey, blue)
- `shape` - "dot" (filled) or "ring" (outline)
- `text` - Status message

### Viewing the Canvas

Get the visual SVG representation of the flow:

```javascript
const canvas = get_canvas_svg();
// Returns: { svg: "<svg>...</svg>", width: "5000", height: "5000" }
```

The SVG contains:
- **Nodes**: `<g class="node">` elements with position via `transform="translate(x, y)"`
- **Node labels**: `<text class="node-type">` shows the node type/name
- **Node colors**: `fill` attribute on `<rect class="node-body">`
- **Wires**: `<path class="wire-inner">` bezier curves connecting nodes
- **Status indicators**: `<g class="node-status">` with colored circles/squares and text
- **Ports**: `<polygon class="port port-input">` and `port-output`

Use this to verify node placement, check for overlapping nodes, or understand the flow structure visually.

## Limitations

- **Browser sandbox**: No filesystem access (except File System Access API where supported), no raw sockets
- **CORS**: HTTP requests subject to browser same-origin policy
- **Tab lifecycle**: Flows stop when tab closes or sleeps
- **Gestures**: Hardware/media APIs need user click first
- **Storage**: IndexedDB/localStorage limits apply

## AI Communication Nodes

PageNodes includes special nodes for bidirectional AI agent communication:

### mcp-in Node
Receives messages sent by AI agents. Use this as a source node to let the AI control your flows.

```
[mcp-in] → [speech]     // AI speaks to you
[mcp-in] → [function]   // AI triggers processing
```

**Output:**
- `msg.payload` - Message content from AI
- `msg.topic` - Message topic (defaults to "mcp-in")

**Options:**
- `topic` - Filter to only receive messages with matching topic (empty = all)

### mcp-out Node
Sends messages to AI agents. Supports two delivery modes:

```
[voicerec] → [mcp-out]  // Voice input to AI
[sensor] → [mcp-out]    // Sensor data to AI
```

**Input:**
- `msg.payload` - Text or data to send to AI
- `msg.topic` - Optional topic/category

**Delivery Modes:**

1. **Queue mode** (default) — Messages are queued and retrieved when the AI agent polls via `get_mcp_messages`. Status shows queue count (e.g., "Queued: 3").

2. **Gateway mode** — Enable "Send to gateway" to POST messages directly to an AI gateway such as Moltbot. This immediately wakes the agent — no polling required. Configure `host:port` (default `127.0.0.1:18789`) and an auth key. Status shows the gateway address.

Gateway mode enables **out-of-band activation**: events from sensors, voice input, timers, or any flow can wake an AI agent instantly without the agent needing to poll for messages.

### Example: Voice Conversation with AI

```
Voice input to AI:     [voicerec] → [mcp-out]
AI response to user:   [mcp-in] → [speech]
```

**With queue mode**, the AI agent:
1. Calls `get_mcp_messages` to receive voice transcriptions
2. Processes and responds via `send_mcp_message`
3. The response flows through mcp-in to speech output

**With gateway mode**, the flow is the same but the agent is woken immediately when voice input arrives — no polling loop needed.
